# 2025_01_07 (4주차 Day 2)

## 알고리즘

### 시간 복잡도

틈틈이 진행하는 알고리즘 강의, 오늘은 시간/공간 복잡도와 자료구조에 대해 조금이나마 이해도를 높이는 시간을 가졌다. <br>

**시간 복잡도**란? 문제를 해결하는데 걸리는 시간과 입력의 함수 관계. 라고 정의되어 있다. <br>

Big-O 표기법이란 것으로 'O(N)의 시간 복잡도를 가진다' 라는 방식으로 표현한다. <br>

간단한 예시와 함께 머리속에 넣어보자. <br>

```ruby
for (int i = 0; i < (int)arr.size(); i++) { // arr의 길이만큼 아래 연산이 실행
    bool isMax = true;
    for (int j = 0; j < (int)arr.size(); j++) { // arr의 길이만큼 아래 연산이 실행
        if (arr[i] < arr[j]) { // 비교 연산 1번 실행
            isMax = false;
            break;
        }
    }
    if (isMax) { // 비교 연산 1번 실행하지만 미미하므로 편의상 실행시간엔 포함 X
        return arr[i];
    }
}
```

위 함수의 시간 복잡도는 두 번의 *for*문이 돌아가기에 array의 원소 개수 N 만큼의 연산을 N 번 실행, 따라서 N^2 만큼의 시간이 걸렸다고 계산할 수 있겠다. <br>

Big-O 표기법으로는 'O(N^2)의 시간 복잡도를 가진다' 라고 적으면 될 듯 하다. <br>

당연히 시간 복잡도가 낮은, 더 빠른 시간 내에 실행 가능한 함수가 효율이 좋을 것이다. <br>

하지만 프로그램을 짤 때는 항상 **최악의 경우를 기준으로** 계산하는 것이 좋다고 한다. 이 점 유의하자. <br>

### 공간 복잡도

가볍게 개념만 다뤄본 이 친구가 의미하는 바는, '**N개의 입력에 대해 얼마만큼의 공간을 사용하는가**'를 나타내는 척도라고 한다. <br>

마찬가지로 예시를 통해 기억해두자. <br>

```ruby
int largest_product(const vector<int>& arr) {
    vector<int> products; // 배열은 벡터를 쓸겁니다!
    for (int a : arr) {
        for (int b : arr) {
            // products 배열에 원소가 들어가는 이 연산은 (a * b)번이 실행된다. 2중 루프!
            products.push_back(a * b);
        }
    }
    // products의 최대값을 찾는 함수
    int maxVal = *max_element(products.begin(), products.end());
    // 따라서, products의 공간 복잡도는 O(N^2)
    return maxVal;
}
```

데이터 입력에 공간을 지나치게 헤프게 쓰는 것은 필히 지양해야 할 행동이다. <br>

허나 현업단계에서는, '**알고리즘의 성능 향상을 위해 공간을 더 사용하는 것에 절대 주저하지 말라**'고 한다. <br>

잘 기억해 두자. <br>

## 자료구조

C를 배울적에 꽤나 정성껏 공부했던 자료구조에 대해서도 간단하게 알아보는 시간을 가졌다. <br>

배열, 링크드리스트, 스택, 큐.. <br>

이중 링크드리스트는 처음 들어보는 것이었다. 개념 자체는 어렵지 않다. '**유동적으로 떼고 붙이는 것이 가능한 자료구조**'. <br>

첫 노드(Head)가 가리키는 다음 노드를 포인터로 조회에 O(N)에 시간 복잡도를 가지는 리스트다. <br>

장점은 무엇인가? 원소의 삽입/삭제에 강점을 지녔다는 점이다. <br>

연결된 포인터를 끊어 새로운 노드에 앞뒤로 연결해주면 끝. 삽입도 삭제도 간편하다. <br>

그래서 얘는 언제 쓰는가? 장점을 살리는 방향으로, **데이터를 빈헌하게 삽입/삭제해야 할 때 사용하면 된다고 한다. <br>

---

## codeKata

문제를 풀며 느낀 바가 있어 기록으로 남겨볼까 한다. <br>

다음은 문자열을 정수로 반환하는 문제를 해결하기 위해 내가 작성해 본 코드이다. <br>

```ruby
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

// 파라미터로 주어지는 문자열은 const로 주어집니다. 변경하려면 문자열을 복사해서 사용하세요.
int solution(const char* s) {
    size_t length = strlen(s);
    char temp[length];
    int answer = 0;
    
    for(int i=0; i<length; i++){
        temp[i] = s[i];
    }
    
    answer = atoi(temp);
    
    return answer;
}
```

캠프에서 codeKata를 진행하면서 내가 적응하는 부분은 우선, C/C++ 특유의 선언과 문법이다. <br>

문자열을 char* 포인터 타입으로 선언한다던가, 배열의 길이를 구해주는 함수는 문자열의 경우 strlen(s)을, 타입은 size_t로 선언하는 등.. <br>

가장 중요한 문자열->정수 변환 함수는 <stdlib.h> 헤더파일로부터 atoi()라는 함수를 사용한다고 한다. <br>

타입과 함수 단위에 대해서 현재는 chatGPT의 도움을 절실하게 받고있는 상황인데.. 이 친구에게 질문을 하는 것도 꽤나 고심해야 할 부분이다(답을 베껴올 순 없으니까).<br>

이번에 깨달은 것은, 처음 문제와 주어진 코드를 받았을 때 헤더파일을 먼저 보면 이번 문제에서 요구하는 함수에 대해 가닥이 잡힌다는 점이었다. <br>

벌써 C++ 문법을 배운지 3주차인데, 이제와서 이 사실을 깨달은 내 처참한 응용력에 안타까움을 표하며.. 앞으로는 까먹지 않고자 부끄럽지만 기록을 남기는 게 좋겠다 생각했다. <br>

남은시간은 이번주차의 과제에 대해, UE_LOG를 다양한 방법으로 사용하며 가닥을 잡는 시간을 보냈다. <br>
