# 2025_02_04 (8주차 Day 2)

![image](https://github.com/user-attachments/assets/6a60ec86-d910-42f2-830b-3e6360d8faaa) <br>

오늘의 코드카타 시간에는 이 문제를 풀어내는데 실패했다. <br>

문제를 보고 처음 생각한 코드의 흐름은 다음과 같다.
```
// 1. a(이하 number[0])을 기준으로 b(이하 number[1])을 더함 / a+b
// 2. 마지막 루프(int k=0)에서 c=number[k]로 a+b+c==0이 되었을 때 count++
// 3. a와 b는 계속 바꿔줘야하는데..?
    
// 처음 for문(int i=0)을 돌리고, i에 해당하는 인덱스를 number[0](이하 a)와 교체한다.
// number[1](이하 b)도 마찬가지.
// 그리고 1,2번을 반복하면..?
// 교체는 어떻게?
// swap()으로!
```

이렇게 하면 되겠지.. 하고 진행했으나 후에 문제가 있음을 깨달았다. <br>

a+b+c에 대해 중복되는 경우의 수를 배제하지 않았다. <br>

이에 대해 a+b+c가 0이 되는 경우 그 값을 저장하여 같은 조합으로 다시 count가 올라가는 경우를 방지해야겠다는 생각을 해봤으나 시간 내에 코드로는 짜지 못했다.

내일 코드카타 시간에는 위 방법을 통해 중복되는 count를 배제하고 코드를 돌려볼 생각이다. <br>

이후 일과 시간에는 마감이 코앞까지 다가온 과제 수행에 시간을 보냈다. <br>

오늘 과제를 진행함에 있어 마주친 문제와 해결책에 대해 정리해보자. <br>

우선 과제의 핵심이 되는 '이동'과 '회전' 기능을 가진 디폴트 클래스를 각각 구현해봤다. 그 중 '이동' 기능을 구현한 MovingActor 액터 클래스를 배치하고 테스트해봤는데, 불규칙적으로 어딘가 걸린듯 덜덜거리면서 밀리는 현상이 발생했다. <br>

충돌이 문제인가 싶어 범위를 조정해봤지만 여전히 같은 현상이 발생했다. <br>

알아본 결과 문제는 내가 Tick()함수에서 DeltaTime 값을 활용해 액터의 위치를 갱신하는 부분에 있었다. <br>

'MaxRange' 변수를 통해 액터의 위치가 일정 범위를 넘어서면 이동 방향을 반전하게끔 해줬는데, 이때 이동 방향을 반전한 상황에서 이미 범위를 벗어난 위치에 갱신이 되는 바람에 반전이 무한반복 되고있었다. <br>

문제를 해결한 방식은 다음과 같다. 만약 오브젝트의 갱신 위치가 MaxRange를 벗어난 지점일 경우, 오브젝트의 위치를 스타트 지점으로부터 최대 범위에 해당하는 지점으로 갱신해주고 이동 방향을 반전시킨다(* -1). <br>

스타트지점은 StartLocation 변수에 들어있고, 최대 범위의 지점은 이동 방향에 MaxRange를 곱하는 것으로 계산할 수 있었다. 이동 방향의 계산은 검색을 통해 '클램핑'이라는 정규화 기법을 사용해 계산했다.. <br>

![image](https://github.com/user-attachments/assets/73aa8d70-4474-43d2-bf50-4817de400206) <br>

![image](https://github.com/user-attachments/assets/e23e512c-fc1b-4bb4-aae7-99c44c3b5beb) <br>

딱 '이동'과 '회전'만 기능하는 아주 간단한 오브젝트로 이루어진 스테이지를 구현해봤다. 내일까지는 2장을 바탕으로 움직이는 캐릭터를 구현하는데 힘써야겠다.
