# 2025_02_04 (8주차 Day 2)

![image](https://github.com/user-attachments/assets/6a60ec86-d910-42f2-830b-3e6360d8faaa) <br>

오늘의 코드카타 시간에는 이 문제를 풀어내는데 실패했다. <br>

문제를 보고 처음 생각한 코드의 흐름은 다음과 같다.
```
// 1. a(이하 number[0])을 기준으로 b(이하 number[1])을 더함 / a+b
// 2. 마지막 루프(int k=0)에서 c=number[k]로 a+b+c==0이 되었을 때 count++
// 3. a와 b는 계속 바꿔줘야하는데..?
    
// 처음 for문(int i=0)을 돌리고, i에 해당하는 인덱스를 number[0](이하 a)와 교체한다.
// number[1](이하 b)도 마찬가지.
// 그리고 1,2번을 반복하면..?
// 교체는 어떻게?
// swap()으로!
```

이렇게 하면 되겠지.. 하고 진행했으나 후에 문제가 있음을 깨달았다. <br>

a+b+c에 대해 중복되는 경우의 수를 배제하지 않았다. <br>

이에 대해 a+b+c가 0이 되는 경우 그 값을 저장하여 같은 조합으로 다시 count가 올라가는 경우를 방지해야겠다는 생각을 해봤으나 시간 내에 코드로는 짜지 못했다.

내일 코드카타 시간에는 위 방법을 통해 중복되는 count를 배제하고 코드를 돌려볼 생각이다. <br>
