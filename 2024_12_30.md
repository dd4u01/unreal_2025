# 2024_12_30 (3주차 Day 1)

오늘로 캠프가 3주차에 접어들었다. <br>

지난 2주차에는 C++ 입문부터 시작해 클래스에 이르기까지 기본적인 개념들에 대해 빠르게 익히는 시간을 가졌었다. <br>

오늘은 데이터의 저장공간, '메모리'에 대해서 알아보자. <br>

당연하겠지만, 메모리는 한정되어 있기 때문에 효율적으로 사용해야 한다. 이를 어떻게 활용하냐에 따라.. 즉, 어떻게 데이터를 저장하냐에 따라 부르는 방식도 다르다. <br>

첫 번째로는, '**스택 메모리**라고 부르는 것이 있다. <br>

### 스택 메모리란?

일반적인 변수에 경우 대부분이 이 스택 메모리 공간을 차지하게 된다고 한다. <br>

변수의 '**생존 주기**'가 끝나면 할당되었던 메모리는 저절로 회수되는 것이 특징.

그렇다면 변수의 생존주기는? "**선언된 라인을 기준으로 가장 가까운 마침 괄호'}'**"라고 한다. <br>

### 힙 메모리란?

방금 알아본 스택 메모리에는 단점이 있는데, 첫째는 메모리의 영역이 크지 않다는 것이고, 두 번째는 스택에 저장된 메모리는 생존 영역을 벗어나면 자동으로 해지된다는 것이다. <br>

이를 해결하기 위해 활용하는 것이 바로 '힙 메모리'라고 한다. <br>

특징은 다음과 같다. <br>

1. 선언 시 *new*, 해제 시 *delete* 연산자를 사용한다.
2. 스택처럼 자동으로 해지하지 않는다. (바꿔 말하면, 우리가 직접 해지를 해줘야 한다.)
3. 따라서 생존주기는 선언 이후 해지하기 전 까지다.

사용자가 직접 해지를 해줘야 한다는 것은 분명 큰 단점이 될 수 있다. <br>

관리에 소홀하거나 미숙하게 되면 *Dangling Pointer*라는 것이 생길 수도..? <br>

### Dangling Pointer는 뭔데..

![image](https://github.com/user-attachments/assets/b75c44dd-f740-4365-924b-3d9e845d7b67) <br>


가리켜야 할 주소값이 사라져버린 포인터를 뜻한다. 어쩌다 그렇게 되버리는 것이냐? 앞서 할당해주었던 메모리를 해지해버리면, 홀로 남은 포인터가 바로 그렇게 된다. <br>

이러한 경우가 발생하기 않게 해주는, '**스마트 포인터**'라는 것도 있다. 한 번 알아보자. <br>

..호기롭게 말했지만, 여기부터 조금 머리가 아프기 시작했다. <br>

스마트 포인터는 '동적 메모리'를 관리하기 위한 도구로, 그 핵심 원리는 '**레퍼런스 카운터**'다. <br>

#### 레퍼런스 카운터는 또 뭐냐...

대충 이해한 대로 풀어써보자면, 값을 참조하고있는 포인터의 개수가 0이 되면 자동으로 해지하게끔 설계한 방식이랄까. <br>

문자 그대로 '참조하는 개수'를 나타내는 말이다. 그에 따라 파생되는 개념들이 또 있다. <br>

### unique_ptr

이건 레퍼런스 카운터가 최대 1인 스마트 포인터를 나타내는 말이다. <br>

소유권의 이전(move(ptr1))은 가능하지만 복사 혹은 대입은 불가능하다고 한다.

그래서 얘는 어떻게 쓰냐? <br>

![image](https://github.com/user-attachments/assets/d132725b-e1f0-4ea7-ab84-2dc57c6cdcf1) <br>
이렇게 쓴다고 한다.. 

아직 잘 모르겠지만, 단 하나의 소유자가 필요한 리소스가 있을 때 요긴하게 사용한다 하니 기억해두자. <br>

### shared_ptr

이 친구는 앞선 unique_ptr과 다르게 레퍼런스 카운터가 n개가 될 수 있는 스마트 포인터다. <br>

레퍼런스 카운터의 개수를 볼 수 있는 use_count(), 그리고 현재 포인터를 초기화 할 수 있는 reset()을 제공해준다고 적혀있다. <br>

사용법으로는 얕은 복사, 그리고 깊은 복사가 있다고 하는데, 그리 어려운 개념은 아니다. 알아보자. <br>

우선 얕은 복사는 대입 연산자(=)를 활용하여 두 포인터가 같은 위치를 공유하게 만드는 방법이다. 당연하게도 이는 조금 전에 정리한 *dangling pointer*가 발생할 수 있는 위험이 있다. <br>

그렇다면 깊은 복사는 다를까? 다르다. <br>

![image](https://github.com/user-attachments/assets/1be0a5d4-6047-47f5-aa52-8532a7bc1a70) <br>

동일한 값을 가진 메모리를 새로 할당하여 참조하는 방식이기에 dangling pointer는 발생하지 않는다고 한다. <br>

유독 머리를 아프게했던 포인터 개념이 나와서 그랬을까, 정리해보니 비교적 간단한 내용이지만 시간을 꽤 잡아먹은 것 같다.

코딩은 실전. 직접 해보면서 배우기 위한 맞춤 문제가 여기에 있다. <br>

1. 메모리 누수 방지
![image](https://github.com/user-attachments/assets/992cc9a2-6985-48ac-aef8-bc143c6b04c2) <br>

2. 스마트 포인터를 활용한 로그 분석기 구현
![image](https://github.com/user-attachments/assets/4da2abcc-8094-4a22-bfe9-51d7749a8488) <br>

풀이 및 답안과의 비교는 내일의 TIL에 기록하기로 하고, 남은 시간은 문제 풀이에 집중해봐야겠다. <br>
